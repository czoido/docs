#!groovyâ€‹

String getPrevVer(String version) {
    def verTokens = version.tokenize('.')
    major = verTokens[0].toInteger()
    minor = verTokens[1].toInteger() - 1
    patch = verTokens[2].toInteger() 
    return "${major}.${minor}.${patch}"
}

String getBranchName(String version) {
    def verTokens = version.tokenize('.')
    major = verTokens[0].toInteger()
    minor = verTokens[1].toInteger()
    return "release/${major}.${minor}"
}

@NonCPS
def getConanVersion(String versionLine) {
    def versionMatch = versionLine =~ /(?:\')([\d.]+)(?:\-dev)/
    return versionMatch[0][1]
}

node('Linux') {

    // get the default branch
    def verUrl = "https://raw.githubusercontent.com/conan-io/conan/develop/conans/__init__.py"
    def versionLine = sh(returnStdout: true, script: "curl '${verUrl}' | grep __version__").trim()

    // get the branch of the upcoming release
    def devConanVersion = getConanVersion(versionLine)
    def devBranch = getBranchName(devConanVersion)

    // get the branch of the latest published Conan version
    // if we merge something to latest, we also want to make sure
    // that we are merging back those changes to the current release branch
    def currentConanVersion = getPrevVer(devConanVersion)
    def currentReleaseBranch = getBranchName(currentConanVersion)

    boolean triggerPublish = env.BRANCH_NAME == "latest"

    echo devBranch
    echo currentReleaseBranch
    echo env.BRANCH_NAME
    def environmentVars = sh(returnStdout: true, script: "printenv")
    echo environmentVars

    stage('Clone sources') {
        def scmVars = checkout scm
    }

    def image = null
    stage('Build docker image') {
        image = docker.build('conan-docs', '-f .ci/Dockerfile .')  // It should cache the image
    }

    stage('Test build') {
        parallel html: {
            image.inside {
                sh 'make html'
            }
        },
        pdf: {
            image.inside {
                sh 'make latex'
            }
        },
        spelling: {
            image.inside {
                sh 'make spelling'
            }
        },
        linkcheck: {
            image.inside {
                int output = sh(script: 'make linkcheck', returnStatus: true)
                if (output != 0) {
                    currentBuild.result = 'FAILURE'
                    error('Stop here, linkcheck failed!')
                }
            }
        }
    }

    // We have to check now the branches that we want to publish
    // if we are merging back changes from the current release branch
    // and we are not in the middle of developing a patch version
    // latest and release branch should be equal (but we have to exclude from the check
    // thing from _static, _themes, _templates...) if that comparison returns true, we publish
    // the latest branch and also the current release branch
    // 1. check that the commit we are merging is in the current release branch
    // 2. check that latest and current release branch are "equal"
    // 1 && 2 --> publish latest and release branch

    def publishBranches = "latest"
    if (triggerPublish) {
        build(job: 'Conan-Docs-Publish', propagate: true, wait: true, parameters: [
            [$class: 'StringParameterValue', name: 'latest', value: currentReleaseBranch],
            [$class: 'StringParameterValue', name: 'branches_to_publish', value: publishBranches],
            [$class: 'StringParameterValue', name: 'prefix', value: 'https://czoido.github.io/docs/'],
            [$class: 'BooleanParameterValue', name: 'publish', value: true]
        ])
    }
}
